Alarms api
----------

Your containers will automatically generate alarms on critical conditions, those alarms, in addition to being showed via jabber or console, are stored in a database to be easily retrieved via the api.

The amount of alarms to be stored is limited by default to 100 per container (but you can ask your supplier to increase them).

To access the list of stored alarms you call /alarms/:

```sh
curl https://kratos:deimos@foobar.com/api/alarms/
```

Alarms fields
-------------

Each alarm entry exposes the following fields/attributes:

* id (the unique identifier of the alarm)
* container (the uid of the container generating the alarm, required)
* level (identify the type of the alarm, there is a pre-defined list of levels, see below)
* color (a user-defined color in the form #rrggbb, can be used by api GUI)
* class (a user-defined class for the alarm)
* vassal (a user-defined value for the vassal generating the alarm)
* line (the line of code generating the error, useful for storing exceptions)
* filename (the filename generating the error, useful for storing exceptions)
* func (the function generating the error, useful for storing exceptions)
* unix (the unix time of the alarm, required)
* msg (the body of the alarm, required)


Alarms levels
-------------

Currently the following 'levels' are defined. They are conventions (they are effectively simple positive numbers), that can be used in GUIs:

* system (value 0, this is set by default for exceptions generated by the system, like out of quota and out of memory, user-defined alarms cannot have the value 0, it is reserved)
* user (value 1, for generic user-defined alarms)
* exception (value 2, for exceptions)
* traceback (value 3, for tracebacks)
* log (value 4, for generic logging)


Filtering alarms
----------------

the /alarms/ api takes optional search-filters as a query string.

As an example you can filter all the alarms of a container of a specific level:

```sh
curl https://kratos:deimos@foobar.com/api/alarms/?container=30017&level=1
```

The following search filters are available:

* container
* vassal
* class
* color
* level
* line
* filename
* func


Generating alarms
-----------------

You can generate your alarms (to be stored in the api database) via the /alarms/raise/<id> api (aliased as /alarms/trigger/<id>). <id> is the uid of the container, while the body of the request is the raw body of the alarm:

```sh
curl -X POST -d "it's a trap" https://kratos:deimos@foobar.com/api/alarms/raise/30017
```

will create an alarm with the message "it's a trap" for the container 30017

You can pass additional fields value for the alarm as a query string, so for defining the color red and the class 'starwars' you will use:


```sh
curl -X POST -d "it's a trap" https://kratos:deimos@foobar.com/api/alarms/raise/30017?color=ff0000&class=starwars
```

Til now we have used the customer credentials to generate alarms, but you may want to allow your user to define them or you can simply do not want to store your credentials in your app. For this reason a second authentication mechanism is available for raising alarms based on authentication token.

The first step is generating an authentication key/token for the container using the /alarm_key/<id> api:

```sh
curl https://kratos:deimos@foobar.com/api/alarm_key/30017
```

