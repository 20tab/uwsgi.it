Using uwsgi.it as a customer
----------------------------

When you buy/activate an account on a uwsgi.it-compliant service you will get:

an api base url: like https://foobar.com/api

an api username: like kratos

an api password: like deimos

With those parameters you will be able o configure your services using the HTTP api.

In this quickstart we will use the 'curl' command, but your supplier could give a you a more user-friendly interface (like a web-based one) build over the api

Let's start: get your personal data
-----------------------------------

First step is ensuring your personal data are correct:

```sh
curl https://kratos:deimos@foobar.com/api/me/
```

```json
{
  "company": "God of war S.r.l.",
  "containers": [30001, 30004, 30007, 30009],
  "uuid": "aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee",
  "vat": "01234567890"
}
```

Update personal data
--------------------

It looks like our company value is wrong, le'ts update it with a POST request

```sh
curl -X POST -d '{"company": "God of War 4 S.p.a."}' https://kratos:deimos@foobar.com/api/me/
```

Update password
---------------

As our password has ben generated by the supplier and so (very probably) it is no more private, let's change it with another POST request

```sh
curl -X POST -d '{"password": "deimos17"}' https://kratos:deimos@foobar.com/api/me/
```

Containers
----------

In the first api call we made in this quickstart we have seen how the returned object has a "containers" array.

This array is the list of containers mapped to our account. Containers are the "virtual systems/jail" you will use for hosting your applications.

We can get a more verbose list of our containers with:

```sh
curl https://kratos:deimos17@foobar.com/api/me/containers/
```

But most of the time you just want to view a single one:

```sh
curl https://kratos:deimos17@foobar.com/api/containers/30009
```

```json
{
  "uid": 30009,
  "ip": "10.0.0.11",
  "server_address": "1.2.3.4",
  "hostname": "changeme",
  "storage": 1000,
  "uuid": "aaaaaaaa-49ff-4349-8d27-705ca239bb95",
  "server": "fooserver",
  "note": "",
  "quota_threshold": 90,
  "distro_name": null,
  "memory": 500,
  "distro": null,
  "ssh_keys": [],
  "name": "changeme",
  "jid": "",
  "jid_destinations": ""
}
```

this is the response you generally get from a just created container. The storage and memory attributes are in megabytes, and define the resources of the container.

server_address is the ip address you need to DNS point to the domains you want to map to this container.

A container is not started (read you cannot ssh into it) until you assign it an ssh key and a 'distro'

Distributions
-------------

The supplier allows you to choose from a pool of Linux distributions used as the rootfs of your containers (each container can have its distro).

Each distro has an id you can assign to the container object.

To get the list of distros:

```sh
curl https://kratos:deimos17@foobar.com/api/distros/
```

```json
[
  {
    "id": 1,
    "name": "Precise Pangolin - Ubuntu 12.04 LTS (64 bit)"
  },
  {
    "id": 2,
    "name": "Saucy Salamander - Ubuntu 13.10 (64 bit)"
  }
]
```

We want to use Saucy (id 2) so let's assign it to the container 30009:

```sh
curl -X POST -d '{"distro": 2}' https://kratos:deimos17@foobar.com/api/containers/30009
```


SSH keys
--------

To access your container you need ssh keys (there is no, and never will be, support for simple password access)

To set ssh public key:

```sh
curl -X POST -d '{"ssh_keys": ["ssh-rsa ........."]}' https://kratos:deimos17@foobar.com/api/containers/30009
```

you can assign multiple keys in one shot:


```sh
curl -X POST -d '{"ssh_keys": ["ssh-rsa .........", "ssh-rsa ........."]}' https://kratos:deimos17@foobar.com/api/containers/30009
```

after a bunch of seconds your instance will start and you will be able to ssh into it:

```sh
ssh 30009@server_address
```

'server_address' is the value returned by your request for container data, in our case will be 1.2.3.4


Domains
-------

Every web application need a domain to be accessed.

Domains are mapped to a customer, so multiple containers can use them (to implement clustering, load balancing or high availability)

You may ask your supplier to map a domain to your account or add by yourself if you have access to its dns zone.

To get the list of domains mapped to your account:

```sh
curl https://kratos:deimos17@foobar.com/api/domains/
```

```json
[
  {
    "uuid": "00000000-8c29-4290-babd-b24d1100e006",
    "id": 1,
    "name": "mydomain.it"
  },
  {
    "uuid": "00000000-72a7-4e53-8939-d9ca4a748bef",
    "id": 15,
    "name": "mydomain.com"
  }
]
```

If you have write access to your domain DNS zone you can add it to your account.

Just get the 'uuid' of your account (we have seen it in the first api call example) and add a TXT record to your zone in the form of

```sh
TXT        uwsgi:aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee
```

To check your zone correctness:

```sh
host -t TXT mynewdomain.org
```

once the zone is updated you can try adding the domain to your account:

```sh
curl -X POST -d '{"name":"mynewdomain.org"}' https://kratos:deimos17@foobar.com/api/domains/
```

if successfull you will get a 202 (Created) response

You can even delete a domain from your account:

```sh
curl -X DELETE -d '{"name":"mynewdomain.org"}' https://kratos:deimos17@foobar.com/api/domains/
```

The first deploy
----------------

Currently (January 2014) the uwsgi.it platform supports python, perl and ruby applications.

We will try to deploy each of them

From the ssh shell, let's create 3 files (in the home):

myapp.py
```python
def application(environ, start_response):
    start_response('200 OK', [('Content-Type','text/plain')])
    return ["Hello i am python"]
```

myapp.pl
```perl
my $app = sub {
    my ($env) = @_;
    return [200, ['Content-Type' => 'text/plain'], ["Hello i am perl"]];
};
```

myapp.ru
```ruby
class MyApp
  def call(env)
    [200, {'Content-Type' => 'text/plain'}, ["Hello i am ruby"]]
  end
end

run MyApp.new
```

Once a container is spawned, a dedicated Emperor will start monitoring the "vassals" directory for uWSGI config files.

Let's deploy the perl one:

vassals/perlapp.ini
```ini
[uwsgi]
plugin = 0:psgi
psgi = $(HOME)/myapp.pl
domain = mynewdomain.org
```

and visit your domain. 

If all goes well you should see the hello message, otherwise check the logs/ directory (in your home) for errors.

Now let's deploy the python one

vassals/pythonapp.ini
```ini
[uwsgi]
plugin = 0:python
wsgi-file = $(HOME)/myapp.py
domain = mynewdomain.org
```

and visit your domain multiple times (use curl this time for better experience, will soon discover why...) 

you will note how the previous perl instance will continue to answer in a round robin fashion with your python one.

Yes, multiple vassals can serve the same domain and load balancing will be automatically enabled. This allows lot of tricks and (more important) true high availability reloads when updating code !

Finally, we deploy the ruby app

vassals/rubyapp.ini
```ini
[uwsgi]
plugin = 0:rack
rack = $(HOME)/myapp.ru
domain = mynewdomain.org
```

and as expected, the domain will load balance between the three instances.

If you are a uWSGI user, you may ask what the 'domain' option is (it is not part of standard uWSGI options).

It is a custom option automatically generated by the container Emperor that is defined in that way:

```ini
declare-option2 = domain=socket=/run/$1_%I.socket;subscribe2=server=/run/subscribe/http,key=$1,addr=$(HOME)/run/$1_%I.socket,sign=SHA1:$(HOME)/etc/uwsgi.key;chmod-socket=666
```

pretty complex as it need to configure the secured subscription system and deal with different mount namespaces

The custom options are all defined in the /opt/unbit/uwsgi/shortcuts.ini file (it is automatically merged with your config)

HTTPS/SNI
---------

Clustering
----------

Every server of a uwsgi.it infrastructure is part of a "Legion".

Containers mapped to different servers in the same Legion can build a cluster.

Each Legion has a dedicated ip in failover mode: only a single member of the Legion, named the "Lord" receives requests on that ip. When the Lord dies, a new member takes the ip address and so on.

The Lord load balance requests to the instances subscribed to it.

To enable load balacing for a domain, just DNS map it to the Legion ip.

The legion ip is reported as "legion_address" in the container api data. If there is no legion_address attribute in your responses, it means your server is not part of a Legion (ask your supplier for an upgrade)

Once the domain is DNS mapped, just change you vassal config from:

```ini
domain = mydomain.it
```

to

```ini
cluster-domain = mydomain.it
```

Linking containers
------------------

Rebooting containers
--------------------

to reboot a container just send an "empty object" POST request to its api:

```sh
curl -X POST -d '{}' https://kratos:deimos17@foobar.com/api/containers/30009
```

technically any update to the container object will trigger a reboot (remember it !!!)

Logging
-------

The logs/emperor.log file is created as the default logging file (and rotated when it reaches 100M size).

Each vassal con log whatever (and however) it needs

Alarms
------

The container Emperor automatically set a series of alarms.

You will get an alarm when your container quota is low (you can set the threshold with the quota_threshold item of the container api), when a OOM (out of memory) is triggered and when it is rebooted.

The alarm is broadcasted to all of the conntected container shells and to an optional jabber/xmpp account.

To enable jabber/xmpp alarm just set "jid", "jid_secret" and "jid_destinations" attributes of the container api.

jid and jid_secret are the credentials the Emperor will use to login to a jabber/xmpp server while jid_destinations is the comma-separated list of jid that will receive the alarms.
